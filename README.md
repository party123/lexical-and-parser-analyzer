# lexical-and-parser-analyzer
通过编译原理实现的一个词法分析器和LR1语法分析器
一、词法分析器
用文本保存待输入的正规文法，用fgets函数读入文本内容，对正规文法进行转化和处理。将非终结符建立不同的状态，终结符则为状态之间的边，用map结构建立状态编号和具体符号的一一映射，用二维数组存储相应的状态转化间的边的编号，即终结符的编号，即可建立相应的NFA。
NFA建立好后，其实对于一些正规文法已经可以识别，但是按照普遍以及规范的做法，需要将NFA转化为相应的DFA，用DFA去识别token串。转化方法如下：首先建立每个状态的闭包，即通过空可以到达的等价状态，接下来依次遍历每个状态通过同一终结符可达到的状态集，因为不知道大小，所以在这里用到了vector容器存储，相当于一个大小可变的临时数组，存储对应的状态集，然后搜索之前的状态集，依次比对，如果之前已经存在则直接找到该状态集编号，添加到DFA的二维数组中，如果没找到则说明是新的状态集，添加新编号并写入DFA数组中，这样就能建立一个DFA的状态集表，用它来识别token串。
接下来是识别和分析过程，即将要分析的源程序写入文本，读取文本内容，然后识别字符串进行状态转化，遇到终态则结束，将分离出来的token串与相应的标识符，关键字，运算符等进行对比，判断和显示其分类。

二、语法分析器----LR(1)
1.首先建立一个文法的类，用于文法的左右分割，将待输入的文法分成左部和右部并分别存储。
2.编写一个函数，用于判断右部能否推出空，这里空用~表示
3.构造文法左部非终结符的FIRST集
4.添加文法$->S并构造LR（1）项目集，这里要用点.表示当前的位置，通过之前求得的FIRST集构造向前搜索符，项目集求出后通过扫描求取项目集的闭包，即要判断.后是否为非终结符，依次求出对应的核并判断是否重复，均不相同的话才应该添加项目集并且添加转化边。如果原有项目集中有和新计算出的项目集相同的，则只应该添加转化边，不应该新添加这个项目集。将产生式相同向前搜索符不同的项目集合并，即可求得最终的项目集。
5.构造状态分析表，首先分为5种情况，建立两个二维数组，一个table数组存储下一个状态的编号，kind数组存储下一个状态的类型。存储类型分为acc=100 ，r=1(终结符) ，S=2(非终结符) ，gui=3 ，others=-1。接下来依次判断存储。当小点的位置等于产生式右部的长度时，则为规约状态，其中若产生式左部为起始符时则为acc状态，存储为100，否则为普通规约状态，此时要遍历查询产生式并记录产生式编号，其类型为规约，编号为规约产生式的编号。
当小点的位置在产生式中间时则为移动状态，将小点的位置+1并求闭包，移动的位置若为非终结符，则其为GOTO状态，若为终结符，则其为ACTION状态。移动时将原产生式的向前搜索符复制到新产生式，然后对其求闭包即可得到新的项目集。若产生的项目集存在时，则将对应的项目集编号i添加进数组中，即Si，若项目集不存在，则添加新编号。至此，LR分析表已经构建完成。
5.下面就是分析过程，设置一个状态栈数组及指针，一个符号栈数组及指针，初始状态为0，初始符号栈为#，接下来根据构造好的LR分析表对待分析符号串进行状态转换及规约，尤其注意在规约时要计算产生式右部长度，然后将相同长度的状态栈进行弹栈，即将指针前移相应位，对规约后的符号即产生式左部，进行状态装换及压栈。
6.输出结果，判断是否符合规定语法。


